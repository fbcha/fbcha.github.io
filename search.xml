<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Xlib库基本图形编程(转载)]]></title>
      <url>http://zerosn.com/2017/01/14/xlib-base/</url>
      <content type="html"><![CDATA[<h5 id="Basic-Graphics-Programming-With-The-Xlib-Library"><a href="#Basic-Graphics-Programming-With-The-Xlib-Library" class="headerlink" title="Basic Graphics Programming With The Xlib Library"></a>Basic Graphics Programming With The Xlib Library</h5><ol><li>Preface</li><li>The Client And Server Model Of The X Window System</li><li>GUI programming - the Asynchronous Programming Model</li><li>Basic Xlib Notions<ol><li>The X Display</li><li>The GC - Graphics Context</li><li>Object Handles</li><li>Memory Allocation For Xlib Structures</li><li>Eventsmm</li></ol></li><li>Compiling Xlib-Based Programs</li><li>Opening And Closing The Connection To An X Server</li><li>Checking Basic Information About A Display</li><li>Creating A Basic Window - Our “hello world” Program</li><li>Drawing In A Window<ol><li>Allocating A Graphics Context (GC)</li><li>Drawing Primitives - Point, Line, Box, Circle…</li></ol></li><li>X Events<ol><li>Registering For Event Types Using Event Masks</li><li>Receiving Events - Writing The Events Loop</li><li>Expose Events</li><li>Getting User Input<ol><li>Mouse Button Click And Release Events</li><li>Mouse Movement Events</li><li>Mouse Pointer Enter And Leave Events</li><li>The Keyboard Focus</li><li>Keyboard Press And Release Events</li></ol></li><li>X Events - A Complete Example</li></ol></li><li>Handling Text And Fonts<ol><li>The Font Structure</li><li>Loading A Font</li><li>Assigning A Font To A Graphics Context</li><li>Drawing Text In A Window</li></ol></li><li>Windows Hierarchy<ol><li>Root, Parent And Child Windows</li><li>Events Propagation</li></ol></li><li>Interacting With The Window Manager<ol><li>Window Properties</li><li>Setting The Window Name And Icon Name</li><li>Setting Preferred Window Size(s)</li><li>Setting Miscellaneous Window Manager Hints</li><li>Setting An Application’s Icon</li></ol></li><li>Simple Window Operations<ol><li>Mapping And UN-Mapping A Window</li><li>Moving A Window Around The Screen</li><li>Resizing A Window</li><li>Changing Windows Stacking Order - Raise And Lower</li><li>Iconifying And De-Iconifying A Window</li><li>Getting Info About A Window</li></ol></li><li>Using Colors To Paint The Rainbow<ol><li>Color Maps</li><li>Allocating And Freeing Color Maps</li><li>Allocating And Freeing A Color Entry</li><li>Drawing With A Color</li></ol></li><li>X Bitmaps And Pixmaps<ol><li>What Is An X Bitmap? An X Pixmap?</li><li>Loading A Bitmap From A File</li><li>Drawing A Bitmap In A Window</li><li>Creating A Pixmap</li><li>Drawing A Pixmap In A Window</li><li>Freeing A Pixmap</li></ol></li><li>Messing With The Mouse Cursor<ol><li>Creating And Destroying A Mouse Cursor</li><li>Setting A Window’s Mou</li></ol></li></ol><hr><p>Preface<br>This tutorial is the first in a series of “would-be” tutorials about graphical programming in the X window environment. By itself, it is useless. A real X programmer usually uses a much higher level of abstraction, such as using Motif (or its free version, lesstiff), GTK, QT and similar libraries. However, we need to start somewhere. More than this, knowing how things work down below is never a bad idea.</p><p>After reading this tutorial, one would be able to write very simple graphical programs, but not programs with a descent user interface. For such programs, one of the previously mentioned libraries would be used.</p><hr><p><strong>X窗口系统的客户/服务器模式</strong><br>当初开发X窗口系统的主要目的只有一个，那就是灵活性。这个灵活性的意思就是说一件东西虽然看起来是在这工作，但却实际上是工作在很远的地方。因此，较低等级的实现部分就必须提供绘制窗口，处理用户输入，画画，使用颜色等工作的工具。在这个要求下，决定了系统被分成了两部分，客户端和服务器端。客户端决定做什么，服务器端执行真正的绘图和接受用户的输入并把它发给客户端。</p><p>这种模式与我们一般习惯的客户端和服务器端的概念是正好相反的。在我们的情况下，用户就坐在服务器端控制的机器前，而客户端这时却是运行在远程主机上。服务器端控制着显示屏，鼠标和键盘。一个客户端也许正连接着服务器端，要求给它画一个窗口（或者是一堆），并要求服务器端把用户对它的窗口的输入传给它。结果，好几个客户端可能连接到了一个服务器端上-有的在运行一个电子邮件软件，有的在运行一个网页浏览器等。当用户输入了指令给窗口，服务器端就会把指令打包成事件传给控制那个窗口的客户端，客户端根据接受到的事件决定干什么然后发送请求让服务器端去画什么。</p><p>以上介绍的会话都是通过X消息协议传输的。该协议是实现在TCP/IP协议上的，它允许在一个网络里的客户端访问这个网络里的任何服务器端。最后，X服务器端可以和客户端运行在同一台机器上以获得性能优化（注意，一个X协议事件可能会达到上百KB），例如使用共享内存，或者使用Unix域socket(在一个Unix系统的两个进程间创建一个本地通道进行通信的方法)。</p><hr><p><strong>图形用户接口（GUI）编程-异步编程模式</strong><br>不像我们通常的令人愉快的程序，一个GUI程序通常使用异步编程模式，也就是下面要介绍的”事件驱动编程”。这个”事件驱动编程”的意思是说程序通常都处于空闲状态，等待从X服务器发来的事件，等收到了事件，才根据事件做相应的事情。一个事件可能是”用户在屏幕某处x,y点击了鼠标左键”，或者是”你控制的窗口需要被重画”。因为程序要回应用户的请求，同时还需要刷新自己的请求队列，因此需要程序尽可能使用较短的事件来处理一个事件（例如，作为一条公认的准则，不能超过200毫秒）。</p><p>这也暗示着当然存在需要程序处理很长时间才能完成的事件（例如一个到远程服务器的网络连接，或者是连接一个数据库，或者是不幸的要处理一个超大文件的复制工作）。这都要求程序使用异步方式来处理而不是通常的同步方式。这时候就应该采用各种各样的异步编程方法来进行这些耗时的工作了，或者干脆把它们交给一个线程或进程来进行。</p><p>根据以上的说明，一个GUI程序就应该像以下的方式来工作：<br>进行初始化工作<br>连接X服务器<br>进行与X相关的初始化工作<br>进行循环<br>从X服务器那里接受下一个事件<br>根据收到的事件发送各种绘图指令给X服务器<br>如果事件是个退出事件，结束循环<br>关闭与X服务器的连接<br>进行资源释放工作</p><hr><p><strong>Xlib的基本思想</strong><br>X协议是非常复杂的，为了大家不用再辛辛苦苦把时间浪费在实现它上面，就有了一个叫”Xlib”的库。这个库提供了访问任何X服务器的非常底层的手段。因为X协议已经被标准化了，理论上客户程序使用任何Xlib的实现都可以访问任何X服务器。在今天，这看起来可能很琐碎，但如果回到那个使用字符终端和专有绘图方法的时代，这应该是一个很大的突破吧。实际上，你很快发现围绕瘦客户机，窗口终端服务器等领域会有许多多么令人兴奋的事情。</p><hr><p><strong>X显示</strong><br>使用XLib的基本思想就是X显示。它代表了一个打开的到X服务器的连接的结构。它隐藏了一个保存有从X服务器来的事件的队列，和一个保存客户程序准备发往服务器的请求队列。在Xlib里，这个结构被命名为显示”Display”。</p><p>当我们打开了一个到X服务器的连接，库就会返回一个指向这个结构的指针。然后，我们就可以使用这个指针来使用Xlib里各种各样的函数。</p><hr><p><strong>GC - 图形上下文</strong><br>当我们进行各种绘图操作（图形，文本等）的时候，我们也许会使用许多参数来指定如何绘制，前景，背景，使用什么颜色，使用什么字体等等，等等。为了避免为每个绘图函数设置数量惊人的参数，我们使用一个叫”GC”的图形上下文结构。我们在这个结构里设置各种绘图参数，然后传给绘图函数就行了。这应当是一个非常方便的方法吧，尤其当我们在进行一连串操作中使用相同的参数时。</p><hr><p><strong>对象句柄</strong><br>当X服务器为我们创建了各种各样的对象的时候 - 例如窗口，绘图区和光标 - 相应的函数就会返回一个句柄。这是一个存在在X服务器空间中的对象的一个标识-而不是在我们的应用程序的空间里。在后面我们就可以使用Xlib的函数通过句柄来操纵这些对象。X服务器维护了一个实际对象到句柄的映射表。Xlib提供了各种类型来定义这些对象。虽然这些类型实际上只是简单的整数，但我们应该继续使用这些类型的名字 - 理由是为了可移植。</p><hr><p><strong>Xlib结构的内存分配</strong><br>Xlib的接口使用了各种类型的结构。有些可以由用户直接来分配内存，有些则只能使用专门的Xlib库函数来分配。在使用库来分配的情况，库会生成有适当初始参数的结构。这对大家来说是非常方便的，指定初始值对于不太熟练的程序员来说是非常头疼的。记住-Xlib想要提供非常灵活的功能，这也就意味着它也会变得非常复杂。提供初始值设置的功能将会帮助那些刚开始使用X的程序员们，同时不会干扰那些高高手们。</p><p>在释放内存时，我们使用与申请的同样方法来释放（例如，使用free()来释放malloc()申请的内存）。所以，我们必须使用XFree()来释放内存。</p><p><strong>事件</strong><br>一个叫”XEvent”的结构来保存从X服务器那里接受到的事件。Xlib提供了非常大量的事件类型。XEvent包括事件的类型，以及与事件相关的数据（例如在屏幕什么地方生成的事件，鼠标键的事件等等），因此，要根据事件类型来读取相应的事件里的数据。这时，XEvent结构使用c语言里的联合来保存可能的数据（如果你搞不清楚c的联合是怎么回事，那你就得花点时间再读读你的教科书了）。结果，我们就可能受到XExpose事件，一个XButton事件，一个XMotion事件等等。</p><hr><p><strong>编译基于Xlib的程序</strong><br>编译基于Xlib的程序需要与Xlib库连接。可以使用下面的命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc prog.c -o prog -lX11</div></pre></td></tr></table></figure></p><p>如果编译器报告找不到X11库，可以试着加上”-L”标志，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc prog.c -o prog -L/usr/X11/lib -lX11</div></pre></td></tr></table></figure></p><p>或者这样（针对使用X11的版本6）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc prog.c -o prog -L/usr/X11R6/lib -lX11</div></pre></td></tr></table></figure></p><p>在SunOs 4 系统上，X的库被放到了 /usr/openwin/lib<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc prog.c -o prog -L/usr/openwin/lib -lX11</div></pre></td></tr></table></figure></p><p>等等，具体情况具体分析</p><hr><p><strong>打开，关闭到一个X服务器的连接</strong><br>一个X程序首先要打开到X服务器的连接。我们需要指定运行X服务器的主机的地址，以及显示器编号。X窗口允许一台机器开多个显示。然而，通常只有一个编号为”0”的显示。如果我们想要连接本地的显示（例如进行显示的机器同时又是客户程序运行的机器），我们可以直接使用”:0”来连接。现在我们举例，连接一台地址是”simey”的机器的显示，我们可以使用地址”simey:0”,下面演示如何进行连接<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* defines common Xlib functions and structs. */</span></span></div><div class="line">.</div><div class="line"><span class="comment">/* this variable will contain the pointer to the Display structure */</span></div><div class="line"><span class="comment">/* returned when opening a connection. */</span></div><div class="line">Display* display;</div><div class="line"><span class="comment">/* open the connection to the display "simey:0". */</span></div><div class="line">display = XOpenDisplay(<span class="string">"simey:0"</span>);</div><div class="line"><span class="keyword">if</span> (display == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot connect to X server %s\n"</span>, <span class="string">"simey:0"</span>);</div><div class="line"><span class="built_in">exit</span> (<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意，通常要为X程序检查是否定义了环境变量”DISPLAY”，如果定义了，可以直接使用它来作为XOpenDisplay()函数的连接参数。</p><p>当程序完成了它的工作且需要关闭到X服务器的连接，它可以这样做：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XCloseDisplay(display);</div></pre></td></tr></table></figure></p><p>这会使X服务器关闭所有为我们创建的窗口以及任何在X服务器上申请的资源被释放。当然，这并不意味着我们的客户程序的结束。</p><hr><p><strong>检查一个显示的相关基本信息</strong><br>一旦我们打开了一个到X服务器的连接，我们应该检查与它相关的一些基本信息：它有什么样的屏幕，屏幕的尺寸（长和宽），它支持多少颜色（黑色和白色？灰度级？256色？或更多），等等。我们将演示一些有关的操作。我们假设变量”display”指向一个通过调用XOpenDisplay()获得的显示结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this variable will be used to store the "default" screen of the */</span></div><div class="line"><span class="comment">/* X server. usually an X server has only one screen, so we&amp;#39;re only */</span></div><div class="line"><span class="comment">/* interested in that screen. */</span></div><div class="line"><span class="keyword">int</span> screen_num;</div><div class="line"><span class="comment">/* these variables will store the size of the screen, in pixels. */</span></div><div class="line"><span class="keyword">int</span> screen_width;</div><div class="line"><span class="keyword">int</span> screen_height;</div><div class="line"><span class="comment">/* this variable will be used to store the ID of the root window of our */</span></div><div class="line"><span class="comment">/* screen. Each screen always has a root window that covers the whole */</span></div><div class="line"><span class="comment">/* screen, and always exists. */</span></div><div class="line">Window root_window;</div><div class="line"><span class="comment">/* these variables will be used to store the IDs of the black and white */</span></div><div class="line"><span class="comment">/* colors of the given screen. More on this will be explained later. */</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> white_pixel;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> black_pixel;</div><div class="line"><span class="comment">/* check the number of the default screen for our X server. */</span></div><div class="line">screen_num = DefaultScreen(display);</div><div class="line"><span class="comment">/* find the width of the default screen of our X server, in pixels. */</span></div><div class="line">screen_width = DisplayWidth(display, screen_num);</div><div class="line"><span class="comment">/* find the height of the default screen of our X server, in pixels. */</span></div><div class="line">screen_height = DisplayHeight(display, screen_num);</div><div class="line"><span class="comment">/* find the ID of the root window of the screen. */</span></div><div class="line">root_window = RootWindow(display, screen_num);</div><div class="line"><span class="comment">/* find the value of a white pixel on this screen. */</span></div><div class="line">white_pixel = WhitePixel(display, screen_num);</div><div class="line"><span class="comment">/* find the value of a black pixel on this screen. */</span></div><div class="line">black_pixel = BlackPixel(display, screen_num);</div></pre></td></tr></table></figure></p><p>还有很多其它的宏来帮助我们获取显示的信息，你可以在Xlib里的参考里找到。另外还有很多相当的函数可以完成相同的工作。</p><hr><p><strong>创建一个基本的窗口 - 我们的”Hello world”程序</strong><br>在我们获得一些窗口的基本信息之后，我们就可以开始创建我们的第一个窗口了。Xlib支持好几个函数来创建窗口，它们其中的一个是XCreateSimpleWindow（）。这个函数使用很少的几个参数来指定窗口的尺寸，位置等。以下是它完整的参数列表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Display* display</div><div class="line">指向显示结构的指针</div><div class="line">Window parent</div><div class="line">新窗口的父窗口的ID。</div><div class="line"><span class="keyword">int</span> x</div><div class="line">窗口的左上X坐标（单位为屏幕像素）</div><div class="line"><span class="keyword">int</span> y</div><div class="line">窗口的左上Y坐标（单位为屏幕像素）</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> width</div><div class="line">窗口的宽度（单位为屏幕像素）</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> height</div><div class="line">窗口的高度（单位为屏幕像素）</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> border_width</div><div class="line">窗口的边框宽度（单位为屏幕像素）</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> border</div><div class="line">用来绘制窗口边框的颜色</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> background</div><div class="line">用来绘制窗口背景的颜色</div></pre></td></tr></table></figure></p><p>让我们创建一个简单的窗口，它的宽度是屏幕宽的1/3，高度是屏幕高的1/3，背景色是白色，边框是黑色，边框的宽度是2个像素。该窗口将会被放置到屏幕的左上角。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this variable will store the ID of the newly created window. */</span></div><div class="line">Window win;</div><div class="line"><span class="comment">/* these variables will store the window&amp;#39;s width and height. */</span></div><div class="line"><span class="keyword">int</span> win_width;</div><div class="line"><span class="keyword">int</span> win_height;</div><div class="line"><span class="comment">/* these variables will store the window&amp;#39;s location. */</span></div><div class="line"><span class="keyword">int</span> win_x;</div><div class="line"><span class="keyword">int</span> win_y;</div><div class="line"><span class="comment">/* calculate the window&amp;#39;s width and height. */</span></div><div class="line">win_width = DisplayWidth(display, screen_num) / <span class="number">3</span>;</div><div class="line">win_height = DisplayHeight(display, screen_num) / <span class="number">3</span>;</div><div class="line"><span class="comment">/* position of the window is top-left corner - 0,0. */</span></div><div class="line">win_x = win_y = <span class="number">0</span>;</div><div class="line"><span class="comment">/* create the window, as specified earlier. */</span></div><div class="line">win = XCreateSimpleWindow(display,</div><div class="line">RootWindow(display, screen_num),</div><div class="line">win_x, win_y,</div><div class="line">win_width, win_height,</div><div class="line">win_border_width, BlackPixel(display, screen_num),</div><div class="line">WhitePixel(display, screen_num));</div></pre></td></tr></table></figure></p><p>事实上我们创建窗口并不意味着它将会被立刻显示在屏幕上，在缺省情况下，新建的窗口将不会被映射到屏幕上，它们是不可见的。为了能让我们创建的窗口能被显示到屏幕上，我们使用函数XMapWindow()：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XMapWindow(win);</div></pre></td></tr></table></figure></p><p>如果想察看目前为止我们所举的例子的代码，请参看源程序simple-window.c。你将会发现两个新的函数 - XFlush() 和XSync()。</p><p>函数XFlush()刷新所有处于等待状态的请求到X服务器 - 非常像函数fflush()刷新所有的内容到标准输出。XSync()也刷新所有处于等待状态的请求，接着等待X服务器处理完所有的请求再继续。在一个一般的程序里这不是必须的（据此你可以发现我们什么时候只是写一个一般的程序），但我们现在把它们提出来，尝试在有或没有这些函数的情况下程序不同的行为。</p><hr><p><strong>在窗口里绘制</strong><br>在窗口里绘图可以使用各种绘图函数 - 画点，线，圈，矩形，等等。为了能在一个窗口里绘图，我们首先需要定义各种参数 - 如线的宽度，使用什么颜色，等等。这都需要使用一个图形上下文（GC）。</p><hr><p><strong>申请一个图形上下文（GC）</strong><br>如我们已经提到的，一个图形上下文定义一些参数来使用绘图函数。因此，为了绘制不同的风格，我们可以在一个窗口里使用多个图形上下文。使用函数 XCreateGC()可以申请到一个新的图形上下文，如以下例（在这段代码里，我们假设”display”指向一个显示结构，”win”是当前创建的一个窗口的ID）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this variable will contain the handle to the returned graphics context. */</span></div><div class="line">GC gc;</div><div class="line"><span class="comment">/* these variables are used to specify various attributes for the GC. */</span></div><div class="line"><span class="comment">/* initial values for the GC. */</span></div><div class="line">XGCValues values = CapButt | JoinBevel;</div><div class="line"><span class="comment">/* which values in &amp;#39;values&amp;#39; to check when creating the GC. */</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> valuemask = GCCapStyle | GCJoinStyle;</div><div class="line"><span class="comment">/* create a new graphical context. */</span></div><div class="line">gc = XCreateGC(display, win, valuemask, &amp;values);</div><div class="line"><span class="keyword">if</span> (gc  <span class="number">0</span>)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="comment">/* ok, now draw the line... */</span></div><div class="line">XDrawLine(display, win, gc, <span class="number">0</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">100</span>);</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure></p><hr><p><strong>获取用户输入</strong><br>就目前来说，用户的输入主要从两个地方过来 - 鼠标和键盘。有各种各样的事件帮助我们来获取用户的输入 - 一个键盘上的键被按下了，一个键盘上的键被松开了，鼠标光标离开了我们的窗口，鼠标光标进入了我们的窗口等等。</p><hr><p><strong>鼠标按键事件和松开事件</strong><br>我们为我们的窗口处理的第一个事件是鼠标按钮时间。为了注册一个这样的事件类型，我们将追加以下的面具<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ButtonPressMask</div></pre></td></tr></table></figure></p><p>通知我们窗口中的任何一个鼠标键按下动作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ButtonReleaseMask</div></pre></td></tr></table></figure></p><p>通知我们窗口中的任何一个鼠标键松开动作<br>在我们的事件循环中通过switch来检查以下的事件类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ButtonPress</div></pre></td></tr></table></figure></p><p>在我们的窗口上一个鼠标键被按下了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ButtonRelease</div></pre></td></tr></table></figure></p><p>在我们的窗口上一个鼠标键被松开了<br>在事件结构里，通过”an_event.xbutton”来获得事件的类型，另外它还包括下面这些有趣的内容：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Window window</div></pre></td></tr></table></figure></p><p>事件发送的目标窗口的ID（如果我们为多个窗口注册了事件）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x, y</div></pre></td></tr></table></figure></p><p>从窗口的左上坐标算起，鼠标键按下时光标在窗口中的坐标<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> button</div></pre></td></tr></table></figure></p><p>鼠标上那个标号的按钮被按下了，值可能是Button1，Button2，Button3<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time time</div></pre></td></tr></table></figure></p><p>事件被放进队列的时间。可以被用来实现双击的处理下面的例子，将演示我们如何在鼠标的位置画点，无论我们何时收到编号为1的按钮的”鼠标按下”的事件时我们画一个黑点，收到编号为2的按钮的”鼠标按下”的事件时我们擦掉那个黑点（例如画一个白点）。我们假设现在有两个GC，gc_draw使用下面的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> ButtonPress:</div><div class="line">    <span class="comment">/* store the mouse button coordinates in &amp;#39;int&amp;#39; variables. */</span></div><div class="line">    <span class="comment">/* also store the ID of the window on which the mouse was */</span></div><div class="line">    <span class="comment">/* pressed. */</span></div><div class="line">    x = an_event.xbutton.x;</div><div class="line">    y = an_event.xbutton.y;</div><div class="line">    the_win = an_event.xbutton.window;</div><div class="line">    <span class="comment">/* check which mouse button was pressed, and act accordingly. */</span></div><div class="line">    <span class="keyword">switch</span> (an_event.xbutton.button) &#123;</div><div class="line">        <span class="keyword">case</span> Button1:</div><div class="line">            <span class="comment">/* draw a pixel at the mouse position. */</span></div><div class="line">            XDrawPoint(display, the_win, gc_draw, x, y);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> Button2:</div><div class="line">            <span class="comment">/* erase a pixel at the mouse position. */</span></div><div class="line">            XDrawPoint(display, the_win, gc_erase, x, y);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>: <span class="comment">/* probably 3rd button - just ignore this event. */</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p><hr><p><strong>鼠标光标的进入和离开事件</strong><br>另一个程序通常会感兴趣的事件是，有关鼠标光标进入一个窗口的领域以及离开那个窗口的领域的事件。有些程序利用该事件来告诉用户程序现在在焦点里面。为了注册这种事件，我们将会在函数XSelectInput()里注册几个面具。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EnterWindowMask</div></pre></td></tr></table></figure></p><p>通知我们鼠标光标进入了我们的窗口中的任意一个<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LeaveWindowMask</div></pre></td></tr></table></figure></p><p>通知我们鼠标光标离开了我们的窗口中的任意一个<br>我们的事件循环中的分支检查将检查以下的事件类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EnterNotify</div></pre></td></tr></table></figure></p><p>鼠标光标进入了我们的窗口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LeaveNotify</div></pre></td></tr></table></figure></p><p>鼠标光标离开了我们的窗口<br>这些事件类型的数据结构通过例如”an_event.xcrossing”来访问，它还包含以下有趣的成员变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Window window</div></pre></td></tr></table></figure></p><p>事件发送的目标窗口的ID（如果我们为多个窗口注册了事件）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Window subwindow</div></pre></td></tr></table></figure></p><p>在一个进入事件中，它的意思是从那个子窗口进入我们的窗口，在一个离开事件中，它的意思是进入了那个子窗口，如果是”none”，它的意思是从外面进入了我们的窗口。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x, y</div></pre></td></tr></table></figure></p><p>从窗口的左上坐标算起，事件产生时鼠标光标在窗口中的坐标<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> mode</div></pre></td></tr></table></figure></p><p>鼠标上那个标号的按钮被按下了，值可能是Button1，Button2，Button3<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time time</div></pre></td></tr></table></figure></p><p>事件被放进队列的时间。可以被用来实现双击的处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> state</div></pre></td></tr></table></figure></p><p>这个事件发生时鼠标按钮（或是键盘键）被按下的情况 - 如果有的话。这个成员使用按位或的方式来表示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Button1Mask</div><div class="line">Button2Mask</div><div class="line">Button3Mask</div><div class="line">Button4Mask</div><div class="line">ShiftMask</div><div class="line">LockMask</div><div class="line">ControlMask</div><div class="line">Mod1Mask</div><div class="line">Mod2Mask</div><div class="line">Mod3Mask</div><div class="line">Mod4Mask</div></pre></td></tr></table></figure></p><p>它们的名字是可以扩展的，当第五个鼠标钮被按下时，剩下的属性就指明其它特殊键（例如Mod1一般是”ALT”或者是”META”键）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bool focus</div></pre></td></tr></table></figure></p><p>当值是True的时候说明窗口获得了键盘焦点，False反之</p><hr><p><strong>键盘焦点</strong><br>在屏幕上同时会有很多窗口，但同一时间只能有一个窗口获得键盘的使用。X服务器是如何知道哪一个窗口可以发送键盘事件呢？这个是通过使用键盘焦点来实现的。在同一时间只能有一个窗口获得键盘焦点。Xlib函数里存在函数允许程序让指定窗口获得键盘焦点。用户通常使用窗口管理器来为窗口设置焦点（通常是点击窗口的标题栏）。</p><p>一旦我们的窗口获得了键盘焦点，每个键的按下和松开都将引起服务器发送事件给我们的程序（如果已经注册了这些事件的类型）。</p><hr><p><strong>键盘键按下和松开事件</strong><br>如果我们程序控制的窗口获得了键盘焦点，它就可以接受按键的按下和松开事件。为了注册这些事件的类型，我们就需要通过函数XSelectInput()来注册下面的面具。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KeyPressMask</div></pre></td></tr></table></figure></p><p>通知我们的程序什么时候按键被按下了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KeyPressMask</div></pre></td></tr></table></figure></p><p>通知我们的程序什么时候按键被松开了<br>我们的事件循环中的分支检查将检查以下的事件类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Window window</div></pre></td></tr></table></figure></p><p>事件发送的目标窗口的ID（如果我们为多个窗口注册了事件）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> keycode</div></pre></td></tr></table></figure></p><p>被按下（或松开）的键的编码。这是一些X内部编码，应该被翻译成一个键盘键符号才能方便使用，将会在下面介绍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x, y</div></pre></td></tr></table></figure></p><p>从窗口的左上坐标算起，事件产生时鼠标光标在窗口中的坐标<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time time</div></pre></td></tr></table></figure></p><p>事件被放进队列的时间。可以被用来实现双击的处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> state</div></pre></td></tr></table></figure></p><p>这个事件发生时鼠标按钮（或是键盘键）被按下的情况 - 如果有的话。这个成员使用按位或的方式来表示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Button1Mask</div><div class="line">Button2Mask</div><div class="line">Button3Mask</div><div class="line">Button4Mask</div><div class="line">ShiftMask</div><div class="line">LockMask</div><div class="line">ControlMask</div><div class="line">Mod1Mask</div><div class="line">Mod2Mask</div><div class="line">Mod3Mask</div><div class="line">Mod4Mask</div></pre></td></tr></table></figure></p><p>它们的名字是可以扩展的，当第五个鼠标钮被按下时，剩下的属性就指明其它特殊键（例如Mod1一般是”ALT”或者是”META”键）</p><p>如我们前面所提到的，按键编码对我们来说是没有什么意义的，它是由连接着X服务器的键盘产生的硬件级编码并且是与某个型号的键盘相关的。为了能解释到底是哪个按键产生的事件，我们把它翻译成已经被标准化了的按键符号。我们可以使用函数XKeycodeToKeysym()来完成这个翻译工作。该函数使用3 个参数：一个显示的指针，要被翻译的键盘编码，和一个索引（我们在这里使用”0”）。标准的Xlib键编码可以参考文件”X11/keysymdef.h”。在下面的例子里我们使用函数XkeycodeToKeysym来处理按键操作，我们讲演示如何以以下顺序处理按键事件：按”1”键将会在鼠标的当前位置下画一个点。按下”DEL”键将擦除那个点。按任何字母键（a至z,大写或小写）将在标准输出里打印。其它的按键将会被无视。假设下面的”case”段代码是在一个消息循环中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> KeyPress:</div><div class="line">    <span class="comment">/* store the mouse button coordinates in &amp;#39;int&amp;#39; variables. */</span></div><div class="line">    <span class="comment">/* also store the ID of the window on which the mouse was */</span></div><div class="line">    <span class="comment">/* pressed. */</span></div><div class="line">    x = an_event.xkey.x;</div><div class="line">    y = an_event.xkey.y;</div><div class="line">    the_win = an_event.xkey.window;</div><div class="line"></div><div class="line">    <span class="comment">/* translate the key code to a key symbol. */</span></div><div class="line">    KeySym key_symbol = XKeycodeToKeysym(display, an_event.xkey.keycode, <span class="number">0</span>);</div><div class="line">    <span class="keyword">switch</span> (key_symbol) &#123;</div><div class="line">        <span class="keyword">case</span> XK_1:</div><div class="line">        <span class="keyword">case</span> XK_KP_1: <span class="comment">/* &amp;#39;1&amp;#39; key was pressed, either the normal &amp;#39;1&amp;#39;, or */</span></div><div class="line">        <span class="comment">/* the &amp;#39;1&amp;#39; on the keypad. draw the current pixel. */</span></div><div class="line">            XDrawPoint(display, the_win, gc_draw, x, y);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> XK_Delete: <span class="comment">/* DEL key was pressed, erase the current pixel. */</span></div><div class="line">            XDrawPoint(display, the_win, gc_erase, x, y);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>: <span class="comment">/* anything else - check if it is a letter key */</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (key_symbol &gt;= XK_A &amp;&amp; key_symbol = XK_a &amp;&amp; key_symbol fid);</div></pre></td></tr></table></figure></p><p>“fid”领域是一个XFontStruct结构用来为各种请求识别各种装载的字体。</p><hr><p><strong>在一个窗口中绘制文本</strong><br>我们一旦为我们的GC装载了字体，我们就可以使用例如函数XDrawString()，在我们的窗口里绘制文本。该函数可以在窗口里的一个给定位置里绘制文本。给定的位置将是从被绘制的文本的左下算起，下面是它的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* assume that win_width contains the width of our window, win_height */</span></div><div class="line"><span class="comment">/* contains the height of our window, and &amp;#39;win&amp;#39; is the handle of our window. */</span></div><div class="line"><span class="comment">/* some temporary variables used for the drawing. */</span></div><div class="line"><span class="keyword">int</span> x, y;</div><div class="line"><span class="comment">/* draw a "hello world" string on the top-left side of our window. */</span></div><div class="line">x = <span class="number">0</span>;</div><div class="line">y = <span class="number">0</span>;</div><div class="line">XDrawString(display, win, gc, x, y, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</div><div class="line"><span class="comment">/* draw a "middle of the road" string in the middle of our window. */</span></div><div class="line"><span class="keyword">char</span>* text_string = <span class="string">"middle of the road"</span>;</div><div class="line"><span class="comment">/* find the width, in pixels, of the text that will be drawn using */</span></div><div class="line"><span class="comment">/* the given font. */</span></div><div class="line"><span class="keyword">int</span> string_width = XTextWidth(font_info, text_string, <span class="built_in">strlen</span>(text_string));</div><div class="line"><span class="comment">/* find the height of the characters drawn using this font. */</span></div><div class="line"><span class="keyword">int</span> fond_height = font_info-&gt;ascent + font_info-&gt;descent;</div><div class="line">x = (win_width - string_width) / <span class="number">2</span>;</div><div class="line">y = (win_width - font_height) / <span class="number">2</span>;</div><div class="line">XDrawString(display, win, gc, x, y, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</div></pre></td></tr></table></figure></p><p>以下的说明应该可以使程序更清楚：<br>函数XTextWidth()被用来预测字符串的长度，当它使用指定字体进行绘制时。它被用来检查那里是开始那里是结束使它看起来占据着窗口的中央一个字体的两个名字为”ascent”和”descent”的属性用来指定字体的高。基本上，一个字体的字符是画在一条假象的横线上的。一些字符被画在横线上面，一些画在下面。最高的字符是被画在”font_info-&gt;ascent”线上的，最低的部分则在”font_info-&gt;descent”线下面。因此，这两个值得和指明了字体的高度。</p><p>上面的源程序可以参考文件simple-text.c</p><hr><p><strong>X窗口的组织体系</strong><br>当窗口被显示在X服务器上时，它们通常按照一定组织体系来排序 - 每个窗口可以有子窗口，每个子窗口又可以有自己的子窗口。让我们来查看这个组织体系的一些特性，看看它们是如何来影响例如绘画和事件等处理。</p><hr><p><strong>根窗口，父窗口和子窗口</strong><br>每一个屏幕上都有一个根窗口。根窗口总是占据整个屏幕尺寸。这个窗口无法被销毁，改变尺寸或者图标化。当一个应用程序创建了一些窗口，它先创建至少一个顶层窗口。在被映射到屏幕上后，这个窗口成为一个根窗口的直接子窗口。这个窗口在被映射到屏幕上之前，窗口管理器被告知什么发生了，然后，窗口管理器获得特权成为新顶层窗口的”父亲”。这通常被用来增加一个会包含新窗口的窗口和绘制框架，标题栏，系统菜单等。</p><p>一旦一个顶层窗口（当然它实际上不是一个顶层窗口，因为窗口管理器已经成为它的父窗口了）被创建了，应用程序可以在它里面创建它的子窗口。一个子窗口只能在它的父窗口里显示 - 如果试图把它移动到外面，出去的部分将被父窗口的边框给切掉。任何窗口都可以包含一个以上的子窗口，在这种情况下，这些子窗口将被放置在应用的内部栈上。当一个顶层窗口被打开 - 它的所有子窗口也将随着它被打开。</p><p>以下例子演示如何在一个给定的叫”win”的窗口里打开一个子窗口。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Lets see how to create a child window inside a given window ''win''.</div><div class="line">/* this variable will store the handle of the newly created child window. */</div><div class="line">Window child_win;</div><div class="line">/* these variables will store the window''s width and height. */</div><div class="line">int child_win_width = 50;</div><div class="line">int child_win_height = 30;</div><div class="line">/* these variables will store the window''s location. */</div><div class="line">/* position of the child window is top-left corner of the */</div><div class="line">/* parent window. - 0,0.  */</div><div class="line">int child_win_x = 0;</div><div class="line">int child_win_y = 0;</div><div class="line">/* create the window, as specified earlier. */</div><div class="line">child_win = XCreateSimpleWindow(display, win, child_win_x, child_win_y,            child_win_width, child_win_height,  child_win_border_width,            BlackPixel(display, screen_num), WhitePixel(display, screen_num));</div></pre></td></tr></table></figure></p><hr><p><strong>事件传递</strong><br>先前我们已经讨论了事件传递 - 如果一个窗口收到了一个它不处理的事件 - 它就把该事件发到它的父窗口去。如果那个父窗口也不处理该事件 - 那个父窗口就把该事件发到它的父窗口上去，接下来依此类推。这种行为对一个简单的Xlib程序是没什么用的，但对于抽象级更高的绘图库是有用的。这些抽象级更高的绘图库通常把某个特定窗口的事件联系到一个函数上去。在这种情况下，发送事件到特定的窗口并用适当的函数来处理就非常有用。</p><hr><p><strong>与窗口管理器进行交互</strong><br>在我们察看了如何创建和绘制窗口之后，我们回过头来看一下我们的窗口是如何与它们的环境 - 整个屏幕和其它窗口进行交互的。首先，我们的程序需要与窗口管理器进行交互。</p><p>窗口管理器有责任装饰被绘制的窗口（例如增加框架，一个图标化的按钮，一个系统菜单，一个标题栏），同时在窗口被图标化时绘制图标。它还管理屏幕里的窗口排列顺序以及其它可管理的任务。我们需要给它各种提示以让它以我们需要的方式来对待我们的窗口。</p><hr><p><strong>窗口属性</strong><br>许多与窗口管理器交流的参数都通过叫”properties”的数据来传递。X服务器把这些属性贴到各种窗口上，同时把它们存储成一种可以被各种架构的系统所能读取的格式（记住，一个X客户程序可能运行在一台远程主机上）。属性可以是各种类型 - 数字，字符串，等等。大部分的窗口管理器提示函数使用文本属性。一个叫<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XStringListToTextProperty()</div></pre></td></tr></table></figure></p><p>的函数可以把C语言的字符串转换成X文本属性，转换后的结果就可以传给各色Xlib函数。以下是一个例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This variable will store the newly created property. */</span></div><div class="line">XTextProperty window_title_property;</div><div class="line"><span class="comment">/* This is the string to be translated into a property. */</span></div><div class="line"><span class="keyword">char</span>* window_title = <span class="string">"hello, world"</span>;</div><div class="line"><span class="comment">/* translate the given string into an X property. */</span></div><div class="line"><span class="keyword">int</span> rc = XStringListToTextProperty(&amp;window_title, <span class="number">1</span>, &amp;window_title_property);</div><div class="line"><span class="comment">/* check the success of the translation. */</span></div><div class="line"><span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XStringListToTextProperty - out of memory\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>函数XStringListToTextProperty()接收一个C字符串矩阵（在我们的例子里只有一个）和一个指向XTextProperty型变量的指针为参数，合并C字符串里的属性把值传到XTextProperty型变量里。成功时它返回一个非0值，失败时返回0（例如，没有足够的内存来完成操作）。</p><hr><p><strong>设置窗口名字和图标名字</strong><br>我们需要做的第一件事就是给我们的窗口设置名字。使用函数XSetWMName()。窗口管理器也许会把这个名字显示在窗口标题栏或是在任务栏上。该函数接受3个参数：一个指向显示的指针，一个窗口句柄，和一个包含有我们设置的名字的XTextProperty变量。下面是我们如何做的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* assume that window_title_property is our XTextProperty, and is */</span></div><div class="line"><span class="comment">/* defined to contain the desired window title.                   */</span></div><div class="line">XSetWMName(display, win, &amp;window_title_property);</div></pre></td></tr></table></figure></p><p>为了设置我们的窗口的图标化名字，我们将用相同的方式使用函数XSetWMIconName()。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this time we assume that icon_name_property is an initialized */</span></div><div class="line"><span class="comment">/* XTextProperty variable containing the desired icon name.      */</span></div><div class="line">XSetWMIconName(display, win, &amp;icon_name_property);</div></pre></td></tr></table></figure></p><hr><p><strong>设置满意的窗口尺寸</strong><br>在各种情况下，我们希望让窗口管理器知道我们指定的窗口尺寸以及只允许用户在我们的限定下改变窗口尺寸。例如，一个终端窗口（像xterm），我们总是要求我们的窗口可以包含全部的行和列，因此我们就不能从中间截断我们的显示。在其它情况下，我们不希望我们的窗口可以被改变尺寸（像绝大部分的对话框窗口），等等。我们可以依赖窗口管理器的这个尺寸信息，虽然它可能被简单的忽视掉。我们首先需要创建一个数据结构来包含该信息，填充必要的数据，然后使用函数 XSetWMNormalHints()。下面是如何操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* pointer to the size hints structure. */</span></div><div class="line">XSizeHints* win_size_hints = XAllocSizeHints();</div><div class="line"><span class="keyword">if</span> (!win_size_hints) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XAllocSizeHints - out of memory\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* initialize the structure appropriately. */</span></div><div class="line"><span class="comment">/* first, specify which size hints we want to fill in. */</span></div><div class="line"><span class="comment">/* in our case - setting the minimal size as well as the initial size. */</span></div><div class="line">win_size_hints-&gt;flags = PSize | PMinSize;</div><div class="line"><span class="comment">/* next, specify the desired limits.                             */</span></div><div class="line"><span class="comment">/* in our case - make the window''s size at least 300x200 pixels.*/</span></div><div class="line"><span class="comment">/* and make its initial size 400x250.                            */</span></div><div class="line">win_size_hints-&gt;min_width = <span class="number">300</span>;win_size_hints-&gt;min_height = <span class="number">200</span>;</div><div class="line">win_size_hints-&gt;base_width = <span class="number">400</span>;win_size_hints-&gt;base_height = <span class="number">250</span>;</div><div class="line"><span class="comment">/* pass the size hints to the window manager. */</span></div><div class="line">XSetWMNormalHints(display, win, win_size_hints);</div><div class="line"><span class="comment">/* finally, we can free the size hints structure. */</span></div><div class="line">XFree(win_size_hints);</div></pre></td></tr></table></figure></p><p>请查看你的手册来获取尺寸提示的完整信息。</p><hr><p><strong>设置各种窗口管理器提示</strong><br>使用函数XSetWMHints()还可以设置许多其它的窗口管理器提示。该函数使用一个XWMHints结构来传递参数给窗口管理器。下面是例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* pointer to the WM hints structure. */</span></div><div class="line">XWMHints* win_hints = XAllocWMHints();</div><div class="line"><span class="keyword">if</span> (!win_hints) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XAllocWMHints - out of memory\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* initialize the structure appropriately. */</span></div><div class="line"><span class="comment">/* first, specify which hints we want to fill in. */</span></div><div class="line"><span class="comment">/* in our case - setting the state hint as well as the icon position hint. */</span></div><div class="line">win_hints-&gt;flags = StateHint | IconPositionHint;</div><div class="line"><span class="comment">/* next, specify the desired hints data.                         */</span></div><div class="line"><span class="comment">/* in our case - make the window''s initial state be iconized,   */</span></div><div class="line"><span class="comment">/* and set the icon position to the top-left part of the screen. */</span></div><div class="line">win_hints-&gt;initial_state = IconicState;win_hints-&gt;icon_x = <span class="number">0</span>;</div><div class="line">win_hints-&gt;icon_y = <span class="number">0</span>;</div><div class="line"><span class="comment">/* pass the hints to the window manager. */</span></div><div class="line">XSetWMHints(display, win, win_hints);</div><div class="line"><span class="comment">/* finally, we can free the WM hints structure. */</span></div><div class="line">XFree(win_hints);</div></pre></td></tr></table></figure></p><p>请查阅手册以获取全部选项的详细信息。</p><hr><p><strong>设置一个程序的图标</strong><br>在用户图标化了我们的程序的时候，为了让窗口管理器能为我们的程序设置一个图标，我们使用上面提到的函数XSetWMHints。但是，首先我们需要创建一个包含有图标数据的像素图。X服务器使用像素图来操作图片，将在后面介绍它的详细使用。在这里，我们只是向你展示如何为你的程序设置图标。我们假设你已经得到了一个X bitmap格式的图标文件。</p><p>教程为了方便提供了一个图标文件”icon.bmp” ,下面是代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* include the definition of the bitmap in our program. */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"icon.bmp"</span>;</span></div><div class="line"><span class="comment">/* pointer to the WM hints structure. */</span></div><div class="line">XWMHints* win_hints;</div><div class="line"><span class="comment">/* load the given bitmap data and create an X pixmap containing it. */</span></div><div class="line">Pixmap icon_pixmap = XCreateBitmapFromData(display, win, icon_bitmap_bits,                     icon_bitmap_width, icon_bitmap_height);</div><div class="line"><span class="keyword">if</span> (!icon_pixmap) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XCreateBitmapFromData - error creating pixmap\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* allocate a WM hints structure. */</span></div><div class="line">win_hints = XAllocWMHints();</div><div class="line"><span class="keyword">if</span> (!win_hints) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XAllocWMHints - out of memory\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* initialize the structure appropriately. */</span></div><div class="line"><span class="comment">/* first, specify which size hints we want to fill in. */</span></div><div class="line"><span class="comment">/* in our case - setting the icon''s pixmap. */</span></div><div class="line">win_hints-&gt;flags = IconPixmapHint;</div><div class="line"><span class="comment">/* next, specify the desired hints data.           */</span></div><div class="line"><span class="comment">/* in our case - supply the icon''s desired pixmap.*/</span></div><div class="line">win_hints-&gt;icon_pixmap = icon_pixmap;</div><div class="line"><span class="comment">/* pass the hints to the window manager. */</span></div><div class="line">XSetWMHints(display, win, win_hints);</div><div class="line"><span class="comment">/* finally, we can free the WM hints structure. */</span></div><div class="line">XFree(win_hints);</div></pre></td></tr></table></figure></p><p>你可以使用程序例如”xpaint”来创建使用X bitmap格式的文件。</p><p>我们提供文件simple-wm-hints.c来总结这一节，这段程序包括创建一个窗口，设置窗口管理器提示为在上面显示，以及一个简单的事件循环。它允许用户调整参数以察看提示是如何影响程序的行为的。这可以帮助你了解X程序的可移植性。</p><hr><p><strong>简单窗口操作</strong><br>对我们的窗口，我们可以做更多的一些事情。例如，改变它们的尺寸，打开或关闭它们，图标化它们等。Xlib提供了一系列函数来完成上面提到的功能。</p><hr><p><strong>映射和解除一个窗口的映射</strong><br>首先我们对窗口作的一对操作是映射它到屏幕上去和解除它的映射。映射一个窗口的操作将会使一个窗口显示在屏幕上，如我们在简单窗口程序例子里所看到的。解除映射操作将会把窗口从屏幕里移除出去（虽然作为一个逻辑结点它仍然在X服务器里）。这个可以提供产生窗口被隐藏（映射解除）和再显示（映射）的效果。例如，我们的程序里有一个对话框，我们不需要每次在需要它显示的时候都重新创建一个窗口，我们只是以映射解除的状态创建一次，在用户需要的时候简单的把它映射到屏幕上去就行了。这比每一次都创建它和销毁它要快多了，当然，这需要在客户端和服务器端同时使用更多的内存。</p><p>你应该还记得映射操作是使用函数XMapWindow()。映射解除操作是使用函数XUnmapWindow()，下面是如何使用它们：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* make the window actually appear on the screen. */</span></div><div class="line">XMapWindow(display, win);</div><div class="line"><span class="comment">/* make the window hidden. */</span></div><div class="line">XUnmapWindow(display, win);</div></pre></td></tr></table></figure></p><p>除非整个窗口被其它窗口给覆盖了，一个暴露事件将在映射操作后发给应用程序。</p><hr><p><strong>在屏幕上移动一个窗口</strong><br>我们想做的另一个操作是在屏幕里移动窗口。使用函数XMoveWindow()可以完成这个操作。它接受窗口的新坐标，使用的方法和函数XCreateSimpleWindow()是一样的。一下是调用的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* move the window to coordinates x=400 and y=100. */</span></div><div class="line">XMoveWindow(display, win, <span class="number">400</span>, <span class="number">100</span>);</div></pre></td></tr></table></figure></p><p>注意当窗口移动的时候，窗口的部分可能后被遮住或被重新暴露，这样我们就可能会收到暴露事件。</p><hr><p><strong>改变窗口尺寸</strong><br>接下来我们要做的是改变一个窗口的尺寸。使用函数XResizeWindow()可以完成这个操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* resize the window to width=200 and height=300 pixels. */</span></div><div class="line">XResizeWindow(display, win, <span class="number">200</span>, <span class="number">300</span>);</div></pre></td></tr></table></figure></p><p>我们可以合并移动和改变尺寸操作为一个操作，使用函数XMoveResizeWindow()：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* move the window to location x=20 y=30, and change its size */</span></div><div class="line"><span class="comment">/* to width=100 and height=150 pixels.                        */</span></div><div class="line">XMoveResizeWindow(display, win, <span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">150</span>);</div></pre></td></tr></table></figure></p><hr><p><strong>改变窗口们的栈顺序 - 提升和降低</strong><br>到目前为止我们已经改变了一个单独窗口的许多属性。接下来我们将看看窗口之间的属性。其中一个就是它们的栈属性。也就是说，窗口是如何在屏幕上排列的。最前面的窗口我们说它是在栈顶，最后面的窗口我们说它是在栈底。下面演示我们如何改变窗口的栈顺序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* move the given window to the top of the stack. */</span></div><div class="line">XRaiseWindow(display, win1);</div><div class="line"><span class="comment">/* move the given window to the bottom of the stack. */</span></div><div class="line">XLowerWindow(display, win1);</div></pre></td></tr></table></figure></p><hr><p><strong>图标化和恢复一个窗口</strong><br>在这里我们将要讲解的最后一个操作就是如何把一个窗口变换成图标状态和恢复它。使用函数XIconifyWindow()来把一个窗口变换成图标状态，使用函数XMapWindow()来恢复它。为了帮助理解为什么图标化函数没有一个对应的反函数，我们必须理解当一个窗口被图标化时，实际发生的事情是那个窗口被解除映射了，而它的图表被映射了。结果，如果想使哪个窗口在出现，我们只需要简单的映射它一下就行了。图标实际上是另一个窗口，只不过它与我们的窗口有非常强的联系关系。下面演示如何图标化一个窗口并恢复它：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* iconify our window. Make its icon window appear on the same */</span></div><div class="line"><span class="comment">/* screen as our window (assuming we created our window on the */</span></div><div class="line"><span class="comment">/* default screen).                                            */</span></div><div class="line">XIconifyWindow(display, win, DefaultScreen(display));</div><div class="line"><span class="comment">/* de-iconify our window. the icon window will be automatically */</span></div><div class="line"><span class="comment">/* unmapped by this operation.                                  */</span></div><div class="line">XMapWindow(display, win);</div></pre></td></tr></table></figure></p><hr><p><strong>获得一个窗口的信息</strong><br>与可以为窗口设置许多属性相同，我们也可以要求X服务器提供这些属性的值。例如，我们可以检查窗口现在在屏幕里什么位置，当前尺寸，是否被映射了等等。函数XGetWindowAttributes()可以帮助我们获取那些信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this variable will contain the attributes of the window. */</span></div><div class="line">XWindowAttributes win_attr;</div><div class="line"><span class="comment">/* query the window''s attributes. */</span></div><div class="line">Status rc = XGetWindowAttributes(display, win, &amp;win_attr);</div></pre></td></tr></table></figure></p><p>结构体XWindowAttributes包含了很多数据域，下面是它的一部分：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x, y;</div><div class="line">    窗口的位置，相对于它的父窗口。</div><div class="line"><span class="keyword">int</span> width, height;</div><div class="line">    窗口的宽和高（单位，像素）。</div><div class="line"><span class="keyword">int</span> border_width</div><div class="line">    窗口的边框宽度</div><div class="line">Window root;</div><div class="line">    根窗口，也就是我们的窗口在那个窗口里被显示了。</div></pre></td></tr></table></figure></p><p>这个函数有些问题，就是它返回的是相对于父窗口的位置。这对一些窗口的操作（例如XMoveWindow）是没有什么意义的。为了解决这个问题，我们需要使用两步的操作。首先，我们找出窗口的父窗口的ID。然后我们在使用它来确定窗口相对于屏幕的坐标。我们使用两个前面没有介绍的函数来完成这个计算，XQueryTree()和XTranslateCoordinates()。这两个函数的功能超出了我们的需要，所以我们只关注我们需要的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* these variables will eventually hold the translated coordinates. */</span></div><div class="line"><span class="keyword">int</span> screen_x, screen_y;</div><div class="line"><span class="comment">/* creen_y contain the location of our original */</span></div><div class="line"><span class="comment">/* window, using screen coordinates. */</span></div></pre></td></tr></table></figure></p><p>你可以看到Xlib有时候会让我们处理问题时变得很麻烦。<br>以上的内容可以参考例子window-operations.c 程序。</p><hr><p><strong>使用颜色来绘制彩虹</strong><br>到目前为止，我们的绘制操作都只使用了黑白两色。现在我们就看看如何使用丰富的颜色来绘制。</p><p><strong>颜色映射</strong><br>首先，是没有完全足够的颜色的。屏幕控制器同时只能支持有限的颜色。因此，一个应用程序不能只是要求使用颜色“轻紫红”就盼望这个颜色能被支持。每个应用分配它自己所需要的颜色，如果全部的16或256色入口都已经在使用了，下一个颜色的分配就会失败。</p><p>结果，就介绍使用“一个颜色映射”。一个颜色映射是一个与屏幕控制器同时可以支持的颜色数相同的表。每个表中的节点都为每种颜色包含一个RGB(红，绿和蓝)。当一个应用想在屏幕上绘制时，它并不指定使用什么颜色，而是指定使用映射表里那一个节点，因此，改变表里某个节点的值将会改变程序绘制的颜色。</p><p>为了能让程序员使用他想要的颜色来绘制，提供了颜色映射分配函数。你可以要求分配一个颜色映射节点来对应一个RGB值，然后一个节点的索引值返回给你。如果表满了，这个操作将会失败。你可以接下来要求一个相近的颜色来满足你的需要。这意味着一个相近的颜色将会被绘制到屏幕上去。</p><p>在当今的X 服务器使用的现代显示器上，一般都可以支持上百万的颜色，上面那个限制也许看起来挺傻的，但是记住还有很多古旧的显示卡和显示器在被使用。使用颜色映射，你可以不必考虑服务器的屏幕硬件细节就可以使用它们。在一个支持上百万的显示器上，任何颜色的分配请求都应该会成功。在一个职能支持有限颜色的显示器上可能会使用一个相近颜色来代替你的要求，这可能不好看，但你的程序仍然能工作。</p><p><strong>分配和释放颜色映射</strong><br>当你使用Xlib绘制的时候，你可以选择屏幕的标准颜色映射，或者为你的窗口分配一个新的颜色映射。在后一种情况下，每次鼠标移动到你的窗口上时，你窗口的颜色映射都将替换缺省的屏幕映射，然后你就会看到屏幕花一下其它的窗口颜色也改变了。实际上，这和你在使用“-install”选项运行X应用时效果一样。</p><p>系统定义了宏DefaultColormap来获取屏幕的标准颜色映射：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Colormap screen_colormap = DefaultColormap(display, DefaultScreen(display));</div></pre></td></tr></table></figure></p><p>上面的调用将会返回第一个屏幕的缺省颜色映射的句柄（再多余的提醒一下，一个X服务器可以同时支持数个不同的屏幕，每个屏幕都可以有自己的资源）。</p><p>另一个选项，分配一个颜色映射，像下面这样工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* first, find the default visual for our screen. */</span></div><div class="line">Visual* default_visual = DefaultVisual(display, DefaultScreen(display));</div><div class="line"><span class="comment">/* this creates a new color map. the number of color entries in this map */</span></div><div class="line"><span class="comment">/* is determined by the number of colors supported on the given screen.  */</span></div><div class="line">Colormap my_colormap = XCreateColormap(display, win, default_visual, AllocNone);</div></pre></td></tr></table></figure></p><p>注意，window参数是用来只允许X服务器为指定屏幕分配颜色映射。我们接下来可以使用分配来的颜色映射给同一个屏幕里的任意一个窗口使用。</p><p><strong>分配和释放颜色节点</strong><br>一旦我们获得了颜色映射的访问，我们就可以开始分配颜色。使用函数XAllocNameColor()和XAllocClor()来完成这个工作。首先函数 XAllocNameColor()获得颜色的名字（例如”红”，”蓝”，”棕”等等）然后获得能使用的实际相近颜色。函数XAllocColor()访问RGB颜色。两个函数都使用XColor结构，它有以下的一些数据域：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pixel</div><div class="line">    颜色映射节点的索引。</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> red</div><div class="line">    RGB颜色值的红色部分。</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> green</div><div class="line">    RGB颜色值的绿色部分。</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> blue</div><div class="line">    RGB颜色值的蓝色部分。</div></pre></td></tr></table></figure></p><p>下面是使用的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this structure will store the color data actually allocated for us. */</span></div><div class="line">XColor system_color_1, system_color_2;</div><div class="line"><span class="comment">/* this structure will store the exact RGB values of the named color.  */</span></div><div class="line"><span class="comment">/* it might be different from what was actually allocated.             */</span></div><div class="line">XColor exact_color;</div><div class="line"><span class="comment">/* allocate a "red" color map entry. */</span></div><div class="line">Status rc = XAllocNamedColor(display, screen_colormap, <span class="string">"red"</span>, &amp;system_color_1,                             &amp;exact_color);</div><div class="line"><span class="comment">/* make sure the allocation succeeded. */</span></div><div class="line"><span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</div><div class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XAllocNamedColor - allocation of ''red'' color failed.\n"</span>);</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"Color entry for ''red'' - allocated as (%d,%d,%d) in RGB values.\n"</span>,             system_color_1.red, system_color_1.green, system_color_1.blue);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* allocate a color with values (30000, 10000, 0) in RGB. */</span></div><div class="line">system_color_2.red = <span class="number">30000</span>;</div><div class="line">system_color_2.green = <span class="number">10000</span>;</div><div class="line">system_color_2.blue = <span class="number">0</span>;</div><div class="line">Status rc = XAllocColor(display, screen_colormap, &amp;system_color_2);</div><div class="line"><span class="comment">/* make sure the allocation succeeded. */</span></div><div class="line"><span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XAllocColor - allocation of (30000,10000,0) color failed.\n"</span>);</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/* do something with the allocated color... */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>使用一个颜色绘制</strong><br>我们在分配了希望的颜色之后，我们可以使用它们绘制文本或图形。为了达到目的，我们需要把获得的颜色设置给一些GC（图形上下文）作为前景色和背景色，然后使用设置好的GC来进行绘制。使用函数XSetForeground()和XSetBackground()来进行，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* use the previously defined colors as the foreground and background */</span></div><div class="line"><span class="comment">/* colors for drawing using the given GC. assume my_gc is a handle to */</span></div><div class="line"><span class="comment">/* a previously allocated GC.                                         */</span></div><div class="line">XSetForeground(display, my_gc, screen_color_1.pixel);</div><div class="line">XSetForeground(display, my_gc, screen_color_2.pixel);</div></pre></td></tr></table></figure></p><p>如你所见，这个是个使用的例子。实际的绘制工作使用我们以前介绍的绘图函数。注意，为了使用各种颜色完成绘制工作，我们可以使用两种方法。我们可以在调用绘图函数前改变GC的值，也可以使用代表不同颜色的GC。由你自己根据情况使用哪种方法。注意，使用多个GC降消耗X服务器额外的资源，但这样可以使你的代码显的更紧凑。</p><p>作为使用颜色绘制的例子，请察看例子程序color-drawing.c 。这是程序simple-drawing.c 的一个拷贝，我们只是添加了颜色的部分在里面。</p><hr><p><strong>X Bitmaps和Pixmaps</strong><br>一个被称为多媒体的程序所有作的一件事情就是显示图片。在X的世界里，使用bitmaps和pixmaps来实现这个功能。在为我们的程序设置图标的介绍里我们已经使用了它们。现在让我们进一步对它们进行研究，看看在一个窗口里是如何绘制它们的。</p><p>在进入之前有一点需要注意，Xlib不能处理许多现在流行的图片格式，例如gif，jpeg或tiff。这些被留给了应用程序（或者是一些图形处理库）来转换成X服务器可以接受的x bitmaps和x pixmaps。</p><p><strong>什么是一个X Bitmap？和X Pixmap？</strong><br>一个Xbitmap是一个有X窗口系统定义的双色图形格式。在保存在一个文件里的时候，bitmap数据看起来就像一段C源程序。它包括定义图片宽高的变量，一个包含比特值得矩阵（矩阵的尺寸=宽*高），和一个可选的热点位置（将会在后面的鼠标光标的部分进行解释）。</p><p>一个X pixmap是一个X窗口系统在内存里保存图像的格式。该格式可以储存黑色和白色的图片（例如X bitmaps）也可以保存带颜色的图片。这实际上是X协议唯一能支持的图片格式，任何图片如果想被显示在屏幕上前都要先被转换成这种格式。</p><p>实际上，一个X pixmap应该被认为是一个没有被绘制到屏幕上的窗口。许多在窗口上的图形操作也可以工作于X pixmap，只不过使用X pixmap ID来代替窗口ID。事实上，如果你查看手册，你会发现所有的这些函数都是接受一个叫”可画”参数而不是一个窗口参数。因为这两种类型都是可画的，它们都可以被用在例如函数XDrawArc()，XDrawText()等等。</p><p><strong>从一个文件里读取一个Bitmap</strong><br>在图标的程序里，我们已经看过如何从一个文件里把一个Bitmap装载到内存里。前面我们使用的方法是使用C预编译器”#include”来进行，下面我们看看如何直接从文件里读取。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this variable will contain the ID of the newly created pixmap.    */</span></div><div class="line">Pixmap bitmap;</div><div class="line"><span class="comment">/* these variables will contain the dimensions of the loaded bitmap. */</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bitmap_width, bitmap_height;</div><div class="line"><span class="comment">/* these variables will contain the location of the hot-spot of the  */</span></div><div class="line"><span class="comment">/* loaded bitmap.                                                    */</span></div><div class="line"><span class="keyword">int</span> hotspot_x, hotspot_y;</div><div class="line"><span class="comment">/* this variable will contain the ID of the root window of the screen */</span></div><div class="line"><span class="comment">/* for which we want the pixmap to be created.                        */</span></div><div class="line">Window root_win = DefaultRootWindow(display);</div><div class="line"><span class="comment">/* load the bitmap found in the file "icon.bmp", create a pixmap      */</span></div><div class="line"><span class="comment">/* containing its data in the server, and put its ID in the ''bitmap'' */</span></div><div class="line"><span class="comment">/* variable.                                                          */</span></div><div class="line"><span class="keyword">int</span> rc = XReadBitmapFile(display, root_win, <span class="string">"icon.bmp"</span>, &amp;bitmap_width,</div><div class="line">             &amp;bitmap_height, &amp;bitmap, &amp;hotspot_x, &amp;hotspot_y);</div><div class="line"><span class="comment">/* check for failure or success. */</span></div><div class="line"><span class="keyword">switch</span> (rc) &#123;</div><div class="line">    <span class="keyword">case</span> BitmapOpenFailed:</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XReadBitmapFile - could not open file ''icon.bmp''.\n"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> BitmapFileInvalid:</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</div><div class="line">            <span class="string">"XReadBitmapFile - file ''%s'' doesn''t contain a valid bitmap.\n"</span>,                                  <span class="string">"icon.bmp"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> BitmapNoMemory:</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XReadBitmapFile - not enough memory.\n"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> BitmapSuccess:</div><div class="line">        <span class="comment">/* bitmap loaded successfully - do something with it... */</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意对于给定的bitmap参数”root_win”什么作用也不起 - 读取的bitmap并不与这个窗口相联系。这个窗口句柄只是被用来指明bitmap所使用的屏幕。这是非常重要的，bitmap必须支持与屏幕相同数量的颜色，这样它才能发挥作用。</p><hr><p><strong>在一个窗口里绘制图形</strong><br>一旦我们获得了从bitmap里生成的pixmap的句柄，我们就可以使用函数XCopyPlane()把它绘制到窗口里。这个函数可以帮助我们指定什么（一个窗口，甚至另一个pixmap）可以画到这个pixmap上去。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* draw the previously loaded bitmap on the given window, at location   */</span></div><div class="line"><span class="comment">/* ''x=100, y=50'' in that window. we want to copy the whole bitmap, so */</span></div><div class="line"><span class="comment">/* we specify location ''x=0, y=0'' of the bitmap to start the copy from, */</span></div><div class="line"><span class="comment">/* and the full size of the bitmap, to specify how much of it to copy.  */</span></div><div class="line">XCopyPlane(display, bitmap, win, gc, <span class="number">0</span>, <span class="number">0</span>, bitmap_width, bitmap_height,</div><div class="line">           <span class="number">100</span>, <span class="number">50</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>如你所见，我们可以只拷贝制定的矩形区而不是整个pixmap。另外还需要注意的是函数XCopyPlane的最后一个参数（那个结尾的”1”）。该参数指定了那个平面被从源里拷贝出来。对于bitmaps，我们通常只拷贝平面1。到了下面我们讨论颜色深度的时候你就能确切的明白为什么这么做。</p><hr><p><strong>创建一个Pixmap</strong><br>有时我们需要创建一个没有初始化的pixmap，这样我们可以接下来在它上面绘制。这对图像绘制程序是非常有用的。另外，这对读取各种格式的图像数据也是非常有用的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this variable will store the handle of the newly created pixmap. */</span></div><div class="line">Pixmap pixmap;</div><div class="line"><span class="comment">/* this variable will contain the ID of the root window of the screen */</span></div><div class="line"><span class="comment">/* for which we want the pixmap to be created.                        */</span></div><div class="line">Window root_win = DefaultRootWindow(display);</div><div class="line"><span class="comment">/* this variable will contain the color depth of the pixmap to create. */</span></div><div class="line"><span class="comment">/* this ''depth'' specifies the number of bits used to represent a color */</span></div><div class="line"><span class="comment">/* index in the color map. the number of colors is 2 to the power of */</span></div><div class="line"><span class="comment">/* this depth.                                                       */</span></div><div class="line"><span class="keyword">int</span> depth = DefaultDepth(display, DefaultScreen(display));</div><div class="line"><span class="comment">/* create a new pixmap, with a width of 30 pixels, and height of 40 pixels. */</span></div><div class="line">pixmap = XCreatePixmap(display, root_win, <span class="number">30</span>, <span class="number">40</span>, depth);</div><div class="line"><span class="comment">/* just for fun, draw a pixel in the middle of this pixmap. */</span></div><div class="line">XDrawPoint(display, pixmap, gc, <span class="number">15</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure></p><p><strong>在一个窗口里绘制一个Pixmap</strong><br>我们在获得了一个pixmap的句柄后，我们就可以使用它在窗口里绘制，使用函数XCopyArea()。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* draw the previously loaded bitmap on the given window, at location   */</span></div><div class="line"><span class="comment">/* ''x=100, y=50'' in that window. we want to copy the whole bitmap, so */</span></div><div class="line"><span class="comment">/* we specify location ''x=0, y=0'' of the bitmap to start the copy from, */</span></div><div class="line"><span class="comment">/* and the full size of the bitmap, to specify how much of it to copy. */</span></div><div class="line">XCopyPlane(display, bitmap, win, gc, <span class="number">0</span>, <span class="number">0</span>, bitmap_width, bitmap_height,                     <span class="number">100</span>, <span class="number">50</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>如你所见，我们可以拷贝指定的矩形区域而不是整个pixmap。</p><p>另外一个需要被强调注意的是 - 可以在同一个屏幕上创建不同深度的pixmap。当我们进行拷贝作业时（往一个窗口上拷贝pixmap等等），我们应该保证源和目标是用相同的深度。如果两个的深度不一样，操作将会失败。除非我们使用前面介绍的函数XCopyPlane()可以完成这个操作。在那样一种情况下，我们拷贝指定的平面到窗口上去，实际上指定了每一个被拷贝的颜色位。这个操作可以制作许多特殊的效果，但这超出了本文的范围。</p><hr><p><strong>释放一个Pixmap</strong><br>最后，当我们完成了对一个pixmap的操作，我们应该释放它所占的资源。使用函数XFreePixmap()。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* free the pixmap with the given ID. */</span></div><div class="line">XFreePixmap(display, pixmap);</div></pre></td></tr></table></figure></p><p>在释放一个pixmap之后 - 我们绝对不能再访问它。<br>作为总结这一章，看一下程序draw-pixmap.c 。</p><hr><p><strong>改变鼠标光标</strong><br>我们经常看到改变鼠标光标的程序（经常被称为X光标）。例如，一个正在埋头工作的程序经常会把光标变成沙漏，提示用户需要等待才能处理新的请求。如果没有这么个提示方法，用户会认为程序已经卡住了。下面让我们看看如何为我们的窗口改变鼠标光标。</p><p><strong>创建和销毁鼠标光标</strong><br>系统提供了两个方法来创建光标。其中一个是使用系统预定义的形状，由Xlib支持。另一个是有程序提供一个bitmap来显示。</p><p>使用前一种方法时，我们使用一个特殊的字体名字”cursor”和相应的函数XCreateFontCursor()。该函数接受一个形状指示然后返回一个代表生成的光标的句柄。<br>文件列出了系统支持的光标类型，下面的是其中的三个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">XC_arrow</div><div class="line">    X服务器显示的普通光标。</div><div class="line">XC_pencil</div><div class="line">    一个笔状的光标。</div><div class="line">XC_watch</div><div class="line">    一个表状沙漏</div></pre></td></tr></table></figure></p><p>使用这些符号来创建光标是非常简单的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span>     </span></div><div class="line"><span class="comment">/* defines XC_watch, etc. */</span></div><div class="line"><span class="comment">/* this variable will hold the handle of the newly created cursor. */</span></div><div class="line">Cursor watch_cursor;</div><div class="line"><span class="comment">/* create a sand watch cursor. */</span></div><div class="line">watch_cursor = XCreateFontCursor(display, XC_watch);</div></pre></td></tr></table></figure></p><p>另一种创建鼠标光标的方法时使用一对pixmaps。一个pixmap定义了光标的形状，另一个是个面具，来指定前一个的什么内容被显示。其它的内容将变成透明的。创建一个那样的光标使用函数XCreatePixmapCursor()。下面的例子里，我们将使用”icon.bmp”来创建光标。我们将假设它已经被装载到内存里去了，并已经被转换成pixmap，返回的句柄被保存到”bitmap”变量里。我们希望它是完全透明的。也就是说，只有黑色颜色的部分会被确实画在屏幕上。为了实现这个效果，我们将会既用它来做光标pixmap且做面具pixmap。希望你能明白为什么这样…<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* this variable will hold the handle of the newly created cursor. *</span></div><div class="line">/Cursor icon_cursor;</div><div class="line">/* first, we need to define foreground and background colors for the cursor. */</div><div class="line">XColor cursor_fg, cursor_bg;</div><div class="line"><span class="comment">/* access the default color map of our screen. */</span></div><div class="line">Colormap screen_colormap = DefaultColormap(display, DefaultScreen(display));</div><div class="line"><span class="comment">/* allocate black and while colors. */</span></div><div class="line">Status rc = XAllocNamedColor(display, screen_colormap, <span class="string">"black"</span>, &amp;cursor_fg,                                          &amp;cursor_fg);</div><div class="line"><span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XAllocNamedColor - cannot allocate ''black'' ??!!??\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">Status rc = XAllocNamedColor(display, screen_colormap, <span class="string">"white"</span>, &amp;cursor_bg, &amp;cursor_bg);</div><div class="line"><span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"XAllocNamedColor - cannot allocate ''white'' ??!!??\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* finally, generate the cursor. make the ''hot spot'' be close to the */</span></div><div class="line"><span class="comment">/* top-left corner of the cursor - location (x=5, y=4). */</span></div><div class="line">icon_cursor = XCreatePixmapCursor(display, bitmap, bitmap, &amp;cursor_fg, &amp;cursor_bg, <span class="number">5</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure></p><p>上面需要说明的是参数”hot spot”。当我们定义了一个光标，我们需要指明光标里的哪一个像素用来生成各种鼠标事件。通常，我们根据习惯来指定一个看起来像”hot spot”的点。例如一个箭头形状的光标，我们就会选择箭头尖为”hot spot”。</p><p>最后，我们不需要再使用光标时，我们可以使用函数XFreeCursor()来释放它的资源：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XFreeCursor(display, icon_cursor);</div></pre></td></tr></table></figure></p><p><strong>设置一个窗口的鼠标光标</strong><br>我们在创建了光标后，就可以告诉X服务器把它贴到我们的任何窗口上去。使用函数XDefineCursor()，X服务器就会在每一次光标移进指定的窗口时改变光标的形状。稍后我们可以使用函数XUndefinCursor()来撤销刚才的指定。这样，鼠标再移进指定的窗口时就会使用缺省的光标。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* attach the icon cursor to our window. */</span></div><div class="line">XDefineCursor(display, win, icon_cursor);</div><div class="line"><span class="comment">/* detach the icon cursor from our window. */</span></div><div class="line">XUndefineCursor(display, win);</div></pre></td></tr></table></figure></p><p>作为例子，请查看程序cursor.c, and see</p><p>how mouse cursors are set, changed and removed. Run the program, place the<br>mouse pointer over the created window, and watch.</p><p>原文地址：<a href="http://linux.chinaunix.net/techdoc/beginner/2009/04/06/1106877.shtml" target="_blank" rel="external">http://linux.chinaunix.net/techdoc/beginner/2009/04/06/1106877.shtml</a></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[phpprobe探针]]></title>
      <url>http://zerosn.com/2016/12/20/php-prober/</url>
      <content type="html"><![CDATA[<h2 id="phpprobe"><a href="#phpprobe" class="headerlink" title="phpprobe"></a>phpprobe</h2><p>phpprobe探针<br>当前版本v1.4</p><p>程序功能：探测web服务器运行环境<br>程序开发：浪子不归（fbcha or shooter）<br>联系方式：fbcha@163.com<br>博客：<a href="https://zerosn.com">https://zerosn.com</a><br>GitHub：<a href="https://github.com/fbcha/phpprobe" target="_blank" rel="external">https://github.com/fbcha/phpprobe</a><br>Git@OSC: <a href="http://git.oschina.net/fbcha/phpprobe" target="_blank" rel="external">http://git.oschina.net/fbcha/phpprobe</a></p><p>phpprobe探针用于探测web运行环境、php信息，查看服务器IP地址，服务器硬盘资源，内存占用，cpu等信息。支持Linux，FreeBSD，Windows，OS X平台。</p><p><strong>下载:</strong></p><p>GitHub：<a href="https://github.com/fbcha/phpprobe/releases" target="_blank" rel="external">https://github.com/fbcha/phpprobe/releases</a></p><p>Git@OSC: <a href="http://git.oschina.net/fbcha/phpprobe/releases" target="_blank" rel="external">http://git.oschina.net/fbcha/phpprobe/releases</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1c2tBGMO" target="_blank" rel="external">https://pan.baidu.com/s/1c2tBGMO</a></p><p>ChinaZ：<a href="http://down.chinaz.com/soft/38362.htm" target="_blank" rel="external">http://down.chinaz.com/soft/38362.htm</a></p><p><strong>更新记录：</strong></p><blockquote><p>2016-12-25<br>V1.4<br>1、增加网络使用状况（linux,freebsd,darwin等）</p><p>2016-12-18<br>V1.3.1<br>1、增加网络使用状况（linux）</p><p>2016-11-24<br>V1.3<br>1、增加服务器性能测试<br>2、增加数据库连接检测<br>3、增加函数检测</p><p>2016-11-08<br>V1.2<br>1、增加打开关闭实时信息的显示<br>2、增加对FreeBSD，Windows，OS X 平台的支持</p><p>2016-10-21<br>V1.1<br>1、增加服务器实时数据，利用图表实时显示</p></blockquote><p><img src="https://github.com/fbcha/phpprobe/raw/master/screenshot.png" alt="image"></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ASUS ZenBook U303UB 6200 笔记本安装archlinux笔记]]></title>
      <url>http://zerosn.com/2016/12/17/asus-zenbook-u303ub-6200-install-archlinux/</url>
      <content type="html"><![CDATA[<h4 id="ASUS-ZenBook-U303UB-6200-笔记本配置："><a href="#ASUS-ZenBook-U303UB-6200-笔记本配置：" class="headerlink" title="ASUS ZenBook U303UB 6200 笔记本配置："></a>ASUS ZenBook U303UB 6200 笔记本配置：</h4><blockquote><p>CPU：六代intel i5-6200<br>内存：4GB 可扩展<br>硬盘：500GB 机械硬盘<br>显卡：NVIDIA GeForce 940M（独显）<br>13.3寸屏，1920x1080分辨率</p></blockquote><p>原装windows 10 home 操作系统，默认分了两个分区，直接把archlinux装在了第二个分区上，运行双系统。</p><p>装archlinux前先进bios把secure boot关闭了，一定要关掉，否则无法安装archlinux，当然也有另外的方法，关闭secure boot最为省事 :)</p><p>下载archlinux系统镜像，可以直接在官方下载，<a href="http://www.archlinux.org" target="_blank" rel="external">http://www.archlinux.org</a></p><p>把下载的archlinux镜像文件写入到u盘中，windows下有很多工具，其它系统也可以用命令写入，网上有很多方法，默认的window 10系统使用的是uefi引导方式，所以直接使用就可以了。</p><p>用做好的u盘启动，进入，出现命令界面，进行安装盘的配置：</p><p>之前网上找到的教程要设置键盘布局、字体、语言什么的，个人感觉没什么必要，除非有些机型，一般没什么问题，显示语言尽量不用动，因为如果设成中文的话，会出现乱码，这个需要改动内核了。网络和pacman软件仓库是要设置的。</p><p><strong>网络设置：</strong><br>因为zenbook u303ub 是一款便携本，所以是不能插网线的（除非外接），直接联接无线网络就可以了，可以使用下边的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># wifi-menu</div></pre></td></tr></table></figure></p><p>然后选择你的网络连接。</p><p><strong>pacman 软件仓库镜像服务器：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">软件仓库全部服务器列表，可以手动去掉前边的“#”启用，然后使用 pacman-Syy 更新本地数据</div><div class="line"># nano /etc/pacman.d/mirrorlist</div><div class="line">也可以通过下边的方法直接选择所有中国大陆镜像服务器</div><div class="line"># grep -A 1 &apos;China&apos; /etc/pacman.d/mirrorlist    // 查看所有中国大陆镜像</div><div class="line"># sed -i &apos;/Score/&#123;/China/!&#123;n;s/^/#/&#125;&#125;&apos; /etc/pacman.d/mirrorlist    // 选择所有中国大陆镜像</div><div class="line"># pacman -Syy    // 更新本地数据</div></pre></td></tr></table></figure></p><p><strong>分区：</strong><br>可以使用fdisk工具来分区，用 lsblk来查看磁盘及分区，因为我的在一块硬盘上装双系统，所以直接把第二分区划分了一个swap分区和系统分区，用mkfs.ext4来格式化系统分区，用mkswap来创建swap分区，用swapon来激活swap分区；这里的设备名移是我的磁盘划分（比如 sda5、sda6），具体可根据自己的实际情况划分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsblk    // 查看磁盘及分区</div><div class="line"># mkfs.ext4 /dev/sda5    // 创建ext4分区</div><div class="line"># mkswap /dev/sda6    // 创建swap交互分区</div><div class="line"># swapon /dev/sda6    // 激活交互分区</div><div class="line">挂载分区：</div><div class="line"># mount /dev/sda5 /mnt    // 挂载根目录</div><div class="line"># mkdir -p /mnt/boot/EFI    // 创建UEFI挂载点</div><div class="line"># mount /dev/sda1 /mnt/boot/EFI    // 挂载UEFI分区，sda1 是共用的UEFI分区，windows的也在这里</div></pre></td></tr></table></figure></p><p><strong>安装基础系统：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># pacstrap -i /mnt base base-devel</div></pre></td></tr></table></figure></p><p><strong>配置fstab：</strong><br>不要重复使用genfstab生成fstab，如果有问题直接修改fstab。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># genfstab -U /mnt &gt;&gt; /mnt/etc/fstab    // 生成fstab</div><div class="line"># cat /mnt/etc/fstab    // 检查生成的fstab</div></pre></td></tr></table></figure></p><p><strong>配置系统：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># arch-chroot /mnt /bin/bash    // 切换到根目录</div><div class="line"># ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime    // 设置中国大陆时区</div></pre></td></tr></table></figure></p><p>硬件时间设置，推荐utc，如果是双系统的话要注意保持两个系统用同样的时间设置，windows使用的是CST时间，设置不对的话，两个系统时间会不同步，所以尽量的让两个系统使用同一时间设置，这里我使用的是本地时间，和windows同步（懒得去修改windows时间 ^_^） ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># hwclock --systohc --utc    // UTC标准时间</div><div class="line"># hwclock --systohc --localtime    // 本地时间</div></pre></td></tr></table></figure></p><p><strong>主机名：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># echo fbchalinux &gt; /etc/hostname</div><div class="line"># nano /etc/hosts    // 将主机名填入</div><div class="line">快速设置</div><div class="line"># HOSTNAME=&apos;fbchalinux&apos;; echo $HOSTNAME &gt; /etc/hostname; \</div><div class="line">sed -i &apos;/localhost/s/$/\t&apos;&quot;$HOSTNAME&quot;&apos;/g&apos; /etc/hosts</div></pre></td></tr></table></figure></p><p><strong>无线网络：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># pacman -S iw wpa_supplicant dialog</div></pre></td></tr></table></figure></p><p>设置root用户密码，创建一个日常用户，添加wheel用户组能够使用sudo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># passwd    // 设置root用户密码</div><div class="line"># useradd -m -g users -G wheel -s /bin/bash fbcha    // 创建日常用户&quot;fbcha&quot;并添加到wheel用户组</div><div class="line"># passwd fbcha    // 为fbcha设置密码</div><div class="line">编辑sudsers文件，去掉 %wheel    ALL=(ALL) 注释，允许wheel用户组使用sudo</div><div class="line"># nano /etc/sudoers</div></pre></td></tr></table></figure></p><p><strong>安装UEFI引导：</strong><br>如果多系统可以安装os-prober自动检索其它系统<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pacman -S dosfstools grub efibootmgr os-prober</div><div class="line"># grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=arch_grub --recheck</div><div class="line"># grub-mkconfig -o /boot/grub/grub.cfg</div></pre></td></tr></table></figure></p><p><strong>卸载分区并重启：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># exit    // 退回安装环境</div><div class="line"># umount -R /mnt    // 卸载新分区</div><div class="line"># reboot    // 重启</div><div class="line">拔掉U盘</div></pre></td></tr></table></figure></p><p>以上是安装，下边是安装后的一些配置，根据自已需要进行安装。</p><h5 id="配置图形界面（本人用的是xfce4桌面环境）："><a href="#配置图形界面（本人用的是xfce4桌面环境）：" class="headerlink" title="配置图形界面（本人用的是xfce4桌面环境）："></a>配置图形界面（本人用的是xfce4桌面环境）：</h5><p><strong>安装显卡驱动：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># lspci | grep &quot;3D|VGA&quot;    // 确定显卡型号，如果只有集显的话可以把3D去掉</div><div class="line"># pacman -S xf86-video-vesa    // 通用显卡驱动</div><div class="line"># pacman -S xf86-video-intel    // intel核显驱动</div><div class="line"># pacman -S nvidia    // nvidia 显卡驱动</div><div class="line">如果双显卡想使用nvidia的optimus技术的话，可以使用bumblebee来实现，因为nvidia的optimus技术在linux下是无法使用的，可以用第三方技术来实现，使用bumblebee方式可以用下边的方法安装，来解决依赖问题：</div><div class="line"># pacman -S intel-dri xf86-video-intel bumblebee nvidia</div><div class="line"># gpasswd -a fbcha bumblebee    // 把用户添加到bumblebee用户组</div></pre></td></tr></table></figure></p><p><strong>安装X窗口系统服务：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pacman -S xorg-server xorg-server-utils</div><div class="line"># pacman -S xf86-input-synaptics    // 触控板驱动</div><div class="line"># pacman -S ttf-dejavu wqy-microhei    // 安装字体</div></pre></td></tr></table></figure></p><p><strong>安装桌面环境：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># pacman -S xfce4 xfce4-goodies</div></pre></td></tr></table></figure></p><p><strong>安装输入法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># pacman -S fcitx-im fcite-configtool    // 安装fcitx</div><div class="line">配置输入法</div><div class="line"># nano ./.xinitrc    // 编辑.xinitrc 没有可以自行创建，在用户目录，然后写入以下信息</div><div class="line">export LANG=zh-CN.UTF-8</div><div class="line">export GTK_IM_MODULE=fcitx</div><div class="line">export QT_IM_MODULE=fcitx</div><div class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</div></pre></td></tr></table></figure></p><p><strong>安装网络连接：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pacman -S networkmanager network-manager-applet xfce4-notifyd hicolor-icon-theme gonme-icon-theme gnome-keyring</div><div class="line">如果有dhcpcd则关闭</div><div class="line"># systemctl disable dhcpcd.service</div><div class="line"># systemctl enable NetworkManager</div><div class="line"># systemctl start NetworkManager</div></pre></td></tr></table></figure></p><p><strong>安装Bluetooth：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># pacman -S bluez bluez-utils blueman</div><div class="line"># systemctl enable bluetooth</div><div class="line">如果需要开机启动蓝牙：</div><div class="line"># nano /etc/udev/rules.d/10-local.rules</div><div class="line">写入以下内容：</div><div class="line"># Set bluetooth power up</div><div class="line">ACTION==&quot;add&quot;, KERNEL==&quot;hci0&quot;, RUN+=&quot;usr/bin/hciconfig hci0 up&quot;</div></pre></td></tr></table></figure></p><p><strong>安装yaourt：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># nano /etc/pacman.conf    // 编辑pacman.conf，写入以下内容</div><div class="line">[archlinuxcn]</div><div class="line">SigLevel = Optional TrustedOnly</div><div class="line">Server = http://mirrors.163.com/archlinux-cn/$arch</div><div class="line">更新本地数据</div><div class="line"># pacman -Syy</div><div class="line">安装yaourt</div><div class="line"># pacman -S yaourt</div></pre></td></tr></table></figure></p><p><strong>关闭独显：</strong><br>下面的配置文件如果没有需要自行创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># pacman -S bbswitch</div><div class="line"># nano /etc/modules-load.d/bbswitch.conf    // 写入下边内容，每次启动都会加载bbswitch模块</div><div class="line">bbswitch</div><div class="line"># nano /etc/modprobe.d/bbswitch.conf    // 写入下边内容，关闭bbswitch默认加载参数</div><div class="line">options bbswitch load_state=0</div><div class="line"># nano /etc/modprobe.d/nouveau_blacklist.conf</div><div class="line">写入下边内容，有时候bbswitch加载了，但是不能关闭显卡，因为有些模块正在占用着，因此要禁掉</div><div class="line">blacklist nouveau</div><div class="line">blacklist nvidiafb</div><div class="line"># nano /usr/lib/systemd/system-shutdown/nvidia_card_enable.sh</div><div class="line">需要运行权限，写入下边内容，每次reboot的时候，显卡都是关闭的，不管是重启到windows还是linux，都会找不到设备，必须彻底关机才行。解决该问题的办法就是每次重启都启用显卡。</div><div class="line">#!/bin/bash</div><div class="line">case &quot;$1&quot; in</div><div class="line">        reboot)</div><div class="line">                echo &quot;Enabling NVIDIA GPU&quot;</div><div class="line">                echo ON &gt; /proc/acpi/bbswitch</div><div class="line">        ;;</div><div class="line">        *)</div><div class="line">esac</div></pre></td></tr></table></figure></p><p><strong>配置laptop-mode-tools：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># yaourt -S laptop-mode-tools</div><div class="line"># pacman -S hdparm cpupower</div><div class="line"># systemctl enable cpupower.service</div><div class="line">修改 /etc/laptop-mode/laptop-mode.conf</div><div class="line">ENABLE_LAPTOP_MODE_ON_AC=0</div><div class="line">默认为 0 ，这里可以修改为 1 ，使用外接电源时也启用laptop_mode</div><div class="line">CONTROL_HD_IDLE_TIMEOUT=1    // 默认为 1 ，修改为 0</div><div class="line">BATT_HD_POWERMGMT=1    // 默认为 1 ，修改为128</div><div class="line"># systemctl enable laptop-mode.service</div></pre></td></tr></table></figure></p><p><strong>安装声音工具：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># pacman -S alsa-utils</div></pre></td></tr></table></figure></p><p><strong>配置Fn+快捷键：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">编辑 /etc/default/grub</div><div class="line"># nano /etc/default/grub</div><div class="line">将 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot; 修改为：</div><div class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet acpi_osi=&quot;</div><div class="line"># nano /usr/share/X11/xorg.conf.d/20-intel.conf    // 如没有自行创建，写入下边内容</div><div class="line">Section &quot;Device&quot;</div><div class="line">        Identifier    &quot;card0&quot;</div><div class="line">        Driver        &quot;intel&quot;</div><div class="line">        Option        &quot;Backlight&quot;    &quot;intel_backlight&quot;</div><div class="line">        BusID        &quot;PCI:0:2:0&quot;</div><div class="line">EndSection</div></pre></td></tr></table></figure></p><p>到此，archlinux 安装配置完毕，以上只是按本人机器做的安装和配置，会和实际情况或其它机型有所不同，仅供参考。</p>]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[All tags]]></title>
      <url>http://zerosn.com/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
